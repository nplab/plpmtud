<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
    There has to be one entity for each item to be referenced.
    An alternate method (rfc include) is described in the references. -->
<!ENTITY RFC678 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0678.xml">
<!ENTITY RFC768 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0768.xml">
<!ENTITY RFC792 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0792.xml">
<!ENTITY RFC1122 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1122.xml">
<!ENTITY RFC1123 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1123.xml">
<!ENTITY RFC1812 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1812.xml">
<!ENTITY RFC1191 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1191.xml">
<!ENTITY RFC1981 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1981.xml">
<!ENTITY RFC2119 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2460 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2460.xml">
<!ENTITY RFC2475 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2475.xml">
<!ENTITY RFC2553 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2553.xml">
<!ENTITY RFC2923 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2923.xml">
<!ENTITY RFC3168 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3168.xml">
<!ENTITY RFC3260 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3260.xml">
<!ENTITY RFC3395 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3395.xml">
<!ENTITY RFC3396 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3396.xml">
<!ENTITY RFC3493 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3493.xml">
<!ENTITY RFC3552 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC3678 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3678.xml">
<!ENTITY RFC3828 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3828.xml">
<!ENTITY RFC4340 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4340.xml">
<!ENTITY RFC4443 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4443.xml">
<!ENTITY RFC4820 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4820.xml">
<!ENTITY RFC4821 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4821.xml">
<!ENTITY RFC4828 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4828.xml">
<!ENTITY RFC4890 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4890.xml">
<!ENTITY RFC4960 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4960.xml">
<!ENTITY RFC5082 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5082.xml">
<!ENTITY RFC5097 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5097.xml">
<!ENTITY RFC5226 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5226.xml">
<!ENTITY RFC6679 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6679.xml">
<!ENTITY RFC6935 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6935.xml">
<!ENTITY RFC6936 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6936.xml">
<!ENTITY RFC6951 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6951.xml">
<!ENTITY RFC6968 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6968.xml">
<!ENTITY RFC6633 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6633.xml">
<!ENTITY RFC8085 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8085.xml">
<!ENTITY RFC8201 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8201.xml">
<!ENTITY RFC8261 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8261.xml">
<!ENTITY RFC8174 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml">
<!ENTITY I-D.ietf-tsvwg-udp-options SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-tsvwg-udp-options-05.xml">
<!ENTITY I-D.ietf-quic-transport SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-quic-transport-16.xml">
<!ENTITY I-D.ietf-intarea-tunnels SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-intarea-tunnels-09.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
    please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
    (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-ietf-tsvwg-datagram-plpmtud-08"
     ipr="trust200902" updates="4821">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
                 or pre5378Trust200902
    you can add the attributes updates="NNNN" and obsoletes="NNNN"
    they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
     full title is longer than 39 characters -->

    <title abbrev="DPLPMTUD">Packetization Layer Path MTU Discovery for
    Datagram Transports</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Godred Fairhurst" initials="G" surname="Fairhurst">
      <organization>University of Aberdeen</organization>

      <address>
        <postal>
          <street>School of Engineering</street>

          <street>Fraser Noble Building</street>

          <city>Aberdeen</city>

          <region></region>

          <code>AB24 3UE</code>

          <country>UK</country>
        </postal>

        <email>gorry@erg.abdn.ac.uk</email>
      </address>
    </author>

    <author fullname="Tom Jones" initials="T" surname="Jones">
      <organization>University of Aberdeen</organization>

      <address>
        <postal>
          <street>School of Engineering</street>

          <street>Fraser Noble Building</street>

          <city>Aberdeen</city>

          <region></region>

          <code>AB24 3UE</code>

          <country>UK</country>
        </postal>

        <email>tom@erg.abdn.ac.uk</email>
      </address>
    </author>

    <author fullname="Michael Tuexen" initials="M" surname="Tuexen">
      <organization>Muenster University of Applied Sciences</organization>

      <address>
        <postal>
          <street>Stegerwaldstrasse 39</street>

          <code>48565</code>

          <city>Steinfurt</city>

          <region></region>

          <country>DE</country>
        </postal>

        <email>tuexen@fh-muenster.de</email>
      </address>
    </author>

    <author fullname="Irene Ruengeler" initials="I" surname="Ruengeler">
      <organization>Muenster University of Applied Sciences</organization>

      <address>
        <postal>
          <street>Stegerwaldstrasse 39</street>

          <code>48565</code>

          <city>Steinfurt</city>

          <region></region>

          <country>DE</country>
        </postal>

        <email>i.ruengeler@fh-muenster.de</email>
      </address>
    </author>
    <author fullname="Timo Voelker" initials="T" surname="Voelker">
      <organization>Muenster University of Applied Sciences</organization>

      <address>
        <postal>
          <street>Stegerwaldstrasse 39</street>

          <code>48565</code>

          <city>Steinfurt</city>

          <region></region>

          <country>DE</country>
        </postal>

        <email>timo.voelker@fh-muenster.de</email>
      </address>
    </author>

    <date day="4" month="April" year="2019" />

    <!-- Meta-data Declarations -->

    <area>Transport</area>

    <workgroup>Internet Engineering Task Force</workgroup>

    <keyword>UDP SCTP Transport PMTUD PLPMTUD</keyword>

    <abstract>
      <t>This document describes a robust method for Path MTU Discovery
      (PMTUD) for datagram Packetization Layers (PLs). The document describes
      an extension to RFC 1191 and RFC 8201, which specifies ICMP-based Path
      MTU Discovery for IPv4 and IPv6. The method allows a PL, or a datagram
      application that uses a PL, to discover whether a network path can
      support the current size of datagram. This can be used to detect and
      reduce the message size when a sender encounters a network black hole
      (where packets are discarded, and no ICMP message is received). The
      method can also probe a network path with progressively larger packets
      to find whether the maximum packet size can be increased. This allows a
      sender to determine an appropriate packet size, providing functionally
      for datagram transports that is equivalent to the Packetization Layer
      PMTUD specification for TCP, specified in RFC 4821.</t>

      <t>The document also provides implementation notes for incorporating
      Datagram PMTUD into IETF datagram transports or applications that use
      datagram transports.</t>

      <t>When published, this specification updates RFC 4821.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>The IETF has specified datagram transport using UDP, SCTP, and DCCP,
      as well as protocols layered on top of these transports (e.g., SCTP/UDP,
      DCCP/UDP, QUIC/UDP), and direct datagram transport over the IP network
      layer. This document describes a robust method for Path MTU Discovery
      (PMTUD) that may be used with these transport protocols (or the
      applications that use their transport service) to discover an
      appropriate size of packet to use across an Internet path.</t>

      <section anchor="Classic-PMTUD" title="Classical Path MTU Discovery">
        <t>Classical Path Maximum Transmission Unit Discovery (PMTUD) can be
        used with any transport that is able to process ICMP Packet Too Big
        (PTB) messages (e.g., <xref target="RFC1191"></xref> and <xref
        target="RFC8201"></xref>). The term PTB message is applied to both
        IPv4 ICMP Unreachable messages (type 3) that carry the error
        Fragmentation Needed (Type 3, Code 4) <xref target="RFC0792"></xref>
        and ICMPv6 packet too big messages (Type 2) <xref
        target="RFC4443"></xref>. When a sender receives a PTB message, it
        reduces the effective MTU to the value reported as the Link MTU in the
        PTB message, and a method that from time-to-time increases the packet
        size in attempt to discover an increase in the supported PMTU. The
        packets sent with a size larger than the current effective PMTU are
        known as probe packets.</t>

        <t>Packets not intended as probe packets are either fragmented to the
        current effective PMTU, or the attempt to send fails with an error
        code. Applications are sometimes provided with a primitive to let them
        read the Maximum Packet Size (MPS), derived from the current effective
        PMTU.</t>

        <t>Classical PMTUD is subject to protocol failures. One failure arises
        when traffic using a packet size larger than the actual PMTU is
        black-holed (all datagrams sent with this size, or larger, are
        silently discarded without the sender receiving PTB messages). This
        could arise when the PTB messages are not delivered back to the sender
        for some reason (see for example <xref target="RFC2923"></xref>).</t>

        <t>Examples where PTB messages are not delivered include:
        <list style="symbols">
          <t>The generation of ICMP messages is usually rate limited. This
          may result in no PTB messages being sent to the sender (see
          section 2.4 of <xref target="RFC4443"></xref>)</t>

          <t>ICMP messages are increasingly filtered by middleboxes
          (including firewalls) <xref target="RFC4890"></xref>. A stateful
          firewall could be configured with a policy to block incoming ICMP
          messages, which would prevent reception of PTB messages to
          endpoints behind this firewall.</t>

          <t>When the router issuing the ICMP message drops a tunneled
          packet, the resulting ICMP message will be directed to the tunnel
          ingress. This tunnel endpoint is responsible for forwarding the
          ICMP message and also processing the quoted packet within the
          payload field to remove the effect of the tunnel, and return a
          correctly formatted ICMP message to the sender <xref
          target="I-D.ietf-intarea-tunnels"></xref>. Failure to do this
          results in black-holing.</t>

          <t>Asymmetry in forwarding can result in there being no route back
          to the original sender, which would prevent an ICMP message being
          delivered to the sender. This can also be an issue when
          policy-based routing is used, Equal Cost Multipath (ECMP) routing
          is used, or a middlebox acts as an application load balancer. An
          example is where the path towards the server is chosen by ECMP
          routing depending on bytes in the IP payload. In this case, when a
          packet sent by the server encounters a problem after the ECMP
          router, then any resulting ICMP message needs to also be directed
          by the ECMP router towards the same server (i.e., ICMP messages
          need to follow the same path as the flows to which they
          correspond). Failure to do this results in black-holing.</t>

          <t>There are cases where the next hop destination fails to receive
          a packet because of its size. This could be due to
          misconfiguration of the layer 2 path between nodes, for instance
          the MTU configured in a layer 2 switch, or misconfiguration of the
          Maximum Receive Unit (MRU). If the packet is dropped by the link,
          this will not cause a PTB message to be sent, and result in
          consequent black-holing.</t>
        </list></t>
        <t>Another failure could result if a node that is not on the
        network path sends a PTB message that attempts to force the sender to
        change the effective PMTU <xref target="RFC8201"></xref>. A sender can
        protect itself from reacting to such messages by utilising the quoted
        packet within a PTB message payload to validate that the received PTB
        message was generated in response to a packet that had actually
        originated from the sender. However, there are situations where a
        sender would be unable to provide this validation.</t>

        <t>Examples where validation of the PTB message is not possible
        include:
          <list style="symbols">
            <t>When a router issuing the ICMP message implements RFC792 <xref
            target="RFC0792"></xref>, it is only required to include the first
            64 bits of the IP payload of the packet within the quoted payload.
            There could be insufficient bytes remaining for the sender to interpret
            the quoted transport information. <vspace/>
            Note: The recommendation in RFC1812 <xref target="RFC1812"></xref> is
            that IPv4 routers return a quoted packet with as much of the original
            datagram as possible without the length of the ICMP datagram exceeding
            576 bytes. IPv6 routers include as much of the invoking packet as possible
            without the ICMPv6 packet exceeding 1280 bytes
            <xref target="RFC4443"></xref>.</t>

            <t>The use of tunnels/encryption can reduce the size of the quoted
            packet returned to the original source address, increasing the
            risk that there could be insufficient bytes remaining for the
            sender to interpret the quoted transport information.</t>

            <t>Even when the PTB message includes sufficient bytes of the
            quoted packet, the network layer could lack sufficient context to
            validate the message, because validation depends on information
            about the active transport flows at an endpoint node (e.g., the
            socket/address pairs being used, and other protocol header
            information).</t>

            <t>When a packet is encapsulated/tunneled over an encrypted
            transport, the tunnel/encapsulation ingress might have
            insufficient context, or computational power, to reconstruct the
            transport header that would be needed to perform validation.</t>
          </list></t>
      </section>

      <section title="Packetization Layer Path MTU Discovery">
        <t>The term Packetization Layer (PL) has been introduced to describe
        the layer that is responsible for placing data blocks into the payload
        of IP packets and selecting an appropriate MPS. This function is often
        performed by a transport protocol, but can also be performed by other
        encapsulation methods working above the transport layer.</t>

        <t>In contrast to PMTUD, Packetization Layer Path MTU Discovery
        (PLPMTUD) <xref target="RFC4821"></xref> does not rely upon reception
        and validation of PTB messages. It is therefore more robust than
        Classical PMTUD. This has become the recommended approach for
        implementing PMTU discovery with TCP.</t>

        <t>It uses a general strategy where the PL sends probe packets to
        search for the largest size of unfragmented datagram that can be sent
        over a network path. The probe packets are sent with a progressively
        larger packet size. If a probe packet is successfully delivered (as
        determined by the PL), then the PLPMTU is raised to the size of the
        successful probe. If no response is received to a probe packet, the
        method reduces the probe size. This PLPMTU is used to set the
        application MPS.</t>

        <t>PLPMTUD introduces flexibility in the implementation of PMTU
        discovery. At one extreme, it can be configured to only perform PTB
        black hole detection and recovery to increase the robustness of
        Classical PMTUD, or at the other extreme, all PTB processing can be
        disabled and PLPMTUD can completely replace Classical PMTUD.</t>

        <t>PLPMTUD can also include additional consistency checks without
        increasing the risk of increased black-holing. For instance, the
        information available at the PL, or higher layers, makes PTB message
        validation more straight forward.</t>
      </section>

      <section title="Path MTU Discovery for Datagram Services">
        <t><xref target="Spec"></xref> of this document presents a set of
        algorithms for datagram protocols to discover the largest size of
        unfragmented datagram that can be sent over a network path. The method
        described relies on features of the PL described in <xref
        target="Requirements"></xref> and applies to transport protocols
        operating over IPv4 and IPv6. It does not require cooperation from the
        lower layers, although it can utilize PTB messages when these received
        messages are made available to the PL.</t>

        <t>The UDP Usage Guidelines <xref target="RFC8085"></xref> state "an
        application SHOULD either use the Path MTU information provided by the
        IP layer or implement Path MTU Discovery (PMTUD)", but does not
        provide a mechanism for discovering the largest size of unfragmented
        datagram that can be used on a network path. Prior to this document,
        PLPMTUD had not been specified for UDP.</t>

        <t>Section 10.2 of <xref target="RFC4821"></xref> recommends a PLPMTUD
        probing method for the Stream Control Transport Protocol (SCTP). SCTP
        utilizes probe packets consisting of a minimal sized HEARTBEAT chunk
        bundled with a PAD chunk as defined in <xref target="RFC4820"></xref>,
        but RFC4821 does not provide a complete specification.
        The present document provides the details to complete that
        specification.</t>

        <t>The Datagram Congestion Control Protocol (DCCP) <xref
        target="RFC4340"></xref> requires implementations to support Classical
        PMTUD and states that a DCCP sender "MUST maintain the MPS allowed for
        each active DCCP session". It also defines the current congestion
        control MPS (CCMPS) supported by a network path. This recommends use
        of PMTUD, and suggests use of control packets (DCCP-Sync) as path
        probe packets, because they do not risk application data loss. The
        method defined in this specification could be used with DCCP.</t>

        <t><xref target="protocol_specific_methods"></xref> specifies the
        method for a set of transports, and provides information to enable the
        implementation of PLPMTUD with other datagram transports and
        applications that use datagram transports.</t>
      </section>
    </section>

    <section title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in BCP 14
      <xref target="RFC2119"></xref> <xref target="RFC8174"></xref> when,
      and only when, they appear in all capitals, as shown here.</t>

      <t>Other terminology is directly copied from <xref
      target="RFC4821"></xref>, and the definitions in <xref
      target="RFC1122"></xref>.</t>

      <t><list style="hanging">
          <t hangText="Actual PMTU:">The Actual PMTU is the PMTU of a network
          path between a sender PL and a destination PL, which the DPLPMTUD
          algorithm seeks to determine.</t>

          <t hangText="Black Holed:">Packets are Black holed when the sender
          is unaware that packets are not delivered to the destination
          endpoint (e.g., when the sender transmits packets of a particular
          size with a previously known effective PMTU and they are silently
          discarded by the network, but is not made aware of a change to the
          path that resulted in a smaller PLPMTU by ICMP messages).</t>

          <t hangText="Classical Path MTU Discovery:">Classical PMTUD is a
          process described in <xref target="RFC1191"></xref> and <xref
          target="RFC8201"></xref>, in which nodes rely on PTB messages to
          learn the largest size of unfragmented datagram that can be used
          across a network path.</t>

          <t hangText="Datagram:">A datagram is a transport-layer protocol
          data unit, transmitted in the payload of an IP packet.</t>

          <t hangText="Effective PMTU:">The Effective PMTU is the current
          estimated value for PMTU that is used by a PMTUD. This is equivalent
          to the PLPMTU derived by PLPMTUD.</t>

          <t hangText="EMTU_S:">The Effective MTU for sending (EMTU_S) is
          defined in <xref target="RFC1122"></xref> as "the maximum IP
          datagram size that may be sent, for a particular combination of IP
          source and destination addresses...".</t>

          <t hangText="EMTU_R:">The Effective MTU for receiving (EMTU_R) is
          designated in <xref target="RFC1122"></xref> as the largest datagram
          size that can be reassembled by EMTU_R ("Effective MTU to
          receive").</t>

          <t hangText="Link:">A Link is a communication facility or medium
          over which nodes can communicate at the link layer, i.e., a layer
          below the IP layer. Examples are Ethernet LANs and Internet (or
          higher) layer and tunnels.</t>

          <t hangText="Link MTU:">The Link Maximum Transmission Unit (MTU) is
          the size in bytes of the largest IP packet, including the IP header
          and payload, that can be transmitted over a link. Note that this
          could more properly be called the IP MTU, to be consistent with how
          other standards organizations use the acronym. This includes the IP
          header, but excludes link layer headers and other framing that is
          not part of IP or the IP payload. Other standards organizations
          generally define the link MTU to include the link layer headers.</t>

          <t hangText="MAX_PMTU:">
          The MAX_PMTU is the largest size of PLPMTU that DPLPMTUD will attempt
          to use.</t>
          <t hangText="MPS:">The Maximum Packet Size (MPS) is the largest size
          of application data block that can be sent across a network path. In
          DPLPMTUD this quantity is derived from the PLPMTU by taking into
          consideration the size of the lower protocol layer headers.</t>

          <t hangText="MIN_PMTU:">The MIN_PMTU is the smallest size of PLPMTU
          that DPLPMTUD will attempt to use.</t>

          <t hangText="Packet:">A Packet is the IP header plus the IP
          payload.</t>

          <t hangText="Packetization Layer (PL):">The Packetization Layer (PL)
          is the layer of the network stack that places data into packets and
          performs transport protocol functions.</t>

          <t hangText="Path:">The Path is the set of links and routers
          traversed by a packet between a source node and a destination node
          by a particular flow.</t>

          <t hangText="Path MTU (PMTU):">The Path MTU (PMTU) is the minimum of
          the Link MTU of all the links forming a network path between a
          source node and a destination node.</t>

          <t hangText="PTB_SIZE:">The PTB_SIZE is a value reported in a
          validated PTB message that indicates next hop link MTU of a router
          along the path.</t>

          <t hangText="PLPMTU:">The Packetization Layer PMTU is an estimate of
          the actual PMTU provided by the DPLPMTUD algorithm.</t>

          <t hangText="PLPMTUD:">Packetization Layer Path MTU Discovery
          (PLPMTUD), the method described in this document for datagram PLs,
          which is an extension to Classical PMTU Discovery.</t>

          <t hangText="Probe packet:">A probe packet is a datagram sent with a
          purposely chosen size (typically the current PLPMTU or larger) to
          detect if packets of this size can be successfully sent end-to-end
          across the network path.</t>
        </list></t>
    </section>

    <section anchor="Requirements"
             title="Features Required to Provide Datagram PLPMTUD">
      <t>TCP PLPMTUD has been defined using standard TCP protocol mechanisms.
      All of the requirements in <xref target="RFC4821"></xref> also apply to
      the use of the technique with a datagram PL. Unlike TCP, some datagram
      PLs require additional mechanisms to implement PLPMTUD.</t>

      <t>There are eight requirements for performing the datagram PLPMTUD
      method described in this specification:
        <list style="numbers">
          <t>PMTU parameters: A DPLPMTUD sender is RECOMMENDED to provide
          information about the maximum size of packet that can be transmitted
          by the sender on the local link (the local Link MTU). It MAY utilize
          similar information about the receiver when this is supplied (note
          this could be less than EMTU_R). This avoids implementations trying
          to send probe packets that can not be transmitted by the local link.
          Too high of a value could reduce the efficiency of the search
          algorithm. Some applications also have a maximum transport protocol
          data unit (PDU) size, in which case there is no benefit from probing
          for a size larger than this (unless a transport allows multiplexing
          multiple applications PDUs into the same datagram).</t>

          <t>PLPMTU: A datagram application using a transport layer not
          supporting fragmentation is REQUIRED to be able to choose
          the size of datagrams sent to the network, up to the PLPMTU, or a
          smaller value (such as the MPS) derived from this. This value is
          managed by the DPLPMTUD method. The PLPMTU (specified as the
          effective PMTU in Section 1 of <xref target="RFC1191"></xref>) is
          equivalent to the EMTU_S (specified in <xref
          target="RFC1122"></xref>).</t>

          <t>Probe packets: On request, a DPLPMTUD sender is REQUIRED to be
          able to transmit a packet larger than the PLMPMTU. This is used to
          send a probe packet. In IPv4, a probe packet MUST be sent with the
          Don't Fragment (DF) bit set in the IP header, and without network
          layer endpoint fragmentation. In IPv6, a probe packet is always sent
          without source fragmentation (as specified in section 5.4 of <xref
          target="RFC8201"></xref>).</t>

          <t>Processing PTB messages: A DPLPMTUD sender MAY optionally utilize
          PTB messages received from the network layer to help identify when a
          network path does not support the current size of probe packet. Any
          received PTB message MUST be validated before it is used to update
          the PLPMTU discovery information <xref target="RFC8201"></xref>.
          This validation confirms that the PTB message was sent in response to
          a packet originating by the sender, and needs to be performed before
          the PLPMTU discovery method reacts to the PTB message.  A PTB message
          MUST NOT be used to increase the PLPMTU <xref
          target="RFC8201"></xref>. </t>


          <t>Reception feedback: The destination PL endpoint is REQUIRED to
          provide a feedback method that indicates to the DPLPMTUD sender when
          a probe packet has been received by the destination PL endpoint. The
          mechanism needs to be robust to the possibility that packets could
          be significantly delayed along a network path. The local PL endpoint
          at the sending node is REQUIRED to pass this feedback to the
          sender-side DPLPMTUD method.</t>

          <t>Probe loss recovery:
          It is RECOMMENDED to use probe packets that do not carry any user
          data.
          Most datagram transports permit this.
          If a probe packet contains user data requiring retransmission
          in case of loss, the PL (or layers above) are REQUIRED
          to arrange any retransmission/repair of any resulting loss.
          DPLPMTUD is REQUIRED to be robust in the case where probe packets
          are lost due to other reasons (including link transmission error,
          congestion).</t>
          <t>Probing and congestion control: The DPLPMTUD sender treats
          isolated loss of a probe packet (with or without a corresponding
          PTB message) as a potential indication of a PMTU limit for the path.
          Loss of a probe packet SHOULD NOT be treated as an indication of
          congestion and the loss SHOULD NOT directly trigger a congestion
          control reaction <xref target="RFC4821"></xref>.</t>

          <t>Shared PLPMTU state: The PLPMTU value could also be stored with
          the corresponding entry in the destination cache and used by other
          PL instances. The specification of PLPMTUD <xref
          target="RFC4821"></xref> states: "If PLPMTUD updates the MTU for a
          particular path, all Packetization Layer sessions that share the
          path representation (as described in Section 5.2 of <xref
          target="RFC4821"></xref>) SHOULD be notified to make use of the new
          MTU".
          Such methods MUST be robust to the wide variety of underlying network
          forwarding behaviors, PLPMTU adjustments based on shared PLPMTU
          values should be incorporated in the search algorithms. Section 5.2
          of <xref target="RFC8201"></xref> provides guidance on the caching
          of PMTU information and also the relation to IPv6 flow labels.</t>
        </list></t>
      <t>In addition, the following principles are stated for design of
      a DPLPMTUD method:
      <list style="symbols">
          <t>MPS: A method is REQUIRED to signal an appropriate MPS to the
          higher layer using the PL. The value of the MPS can change following
          a change to the path. It is RECOMMENDED that methods avoid forcing
          an application to use an arbitrary small MPS (PLPMTU) for
          transmission while the method is searching for the currently
          supported PLPMTU. Datagram PLs do not necessarily support
          fragmentation of PDUs larger than the PLPMTU. A reduced MPS can
          adversely impact the performance of a datagram application.</t>

          <t>Path validation: It is RECOMMENDED that methods are robust to
          path changes that could have occurred since the path characteristics
          were last confirmed, and to the possibility of inconsistent path
          information being received.</t>

          <t>Datagram reordering: A method is REQUIRED to be robust to the
          possibility that a flow encounters reordering, or the traffic
          (including probe packets) is divided over more than one network
          path.</t>

          <t>When to probe: It is RECOMMENDED that methods determine whether
          the path capacity has increased since it last measured the path.
          This determines when the path should again be probed.</t>
        </list></t>
    </section>

    <section title="DPLPMTUD Mechanisms">
      <t>This section lists the protocol mechanisms used in this
      specification.</t>

      <section anchor="Probe" title="PLPMTU Probe Packets">
        <t>The DPLPMTUD method relies upon the PL sender being able to
        generate probe packets with a specific size. TCP is able to generate
        these probe packets by choosing to appropriately segment data being
        sent <xref target="RFC4821"></xref>. In contrast, a datagram PL that
        needs to construct a probe packet has to either request an application
        to send a data block that is larger than that generated by an
        application, or to utilize padding functions to extend a datagram
        beyond the size of the application data block. Protocols that permit
        exchange of control messages (without an application data block) could
        alternatively prefer to generate a probe packet by extending a control
        message with padding data.</t>

        <t>A receiver needs to be able to distinguish an in-band data block
        from any added padding. This is needed to ensure that any added
        padding is not passed on to an application at the receiver.</t>

        <t>This results in three possible ways that a sender can create a
        probe packet listed in order of preference:<list style="hanging">
            <t hangText="Probing using padding data:">A probe packet that
            contains only control information together with any padding, which
            is needed to be inflated to the size required for the probe
            packet. Since these probe packets do not carry an
            application-supplied data block, they do not typically require
            retransmission, although they do still consume network capacity
            and incur endpoint processing.</t>

            <t hangText="Probing using application data and padding data:">A
            probe packet that contains a data block supplied by an application
            that is combined with padding to inflate the length of the
            datagram to the size required for the probe packet. If the
            application/transport needs protection from the loss of this probe
            packet, the application/transport could perform transport-layer
            retransmission/repair of the data block (e.g., by retransmission
            after loss is detected or by duplicating the data block in a
            datagram without the padding data).</t>

            <t hangText="Probing using application data:">A probe packet that
            contains a data block supplied by an application that matches the
            size required for the probe packet. This method requests the
            application to issue a data block of the desired probe size. If
            the application/transport needs protection from the loss of an
            unsuccessful probe packet, the application/transport needs then to
            perform transport-layer retransmission/repair of the data block
            (e.g., by retransmission after loss is detected).</t>
          </list>A PL that uses a probe packet carrying an application data
        block, could need to retransmit this application data block if the
        probe fails. This could need the PL to re-fragment the data block to a
        smaller packet size that is expected to traverse the end-to-end path
        (which could utilize endpoint network-layer or PL fragmentation when
        these are available).</t>

        <t>DPLPMTUD MAY choose to use only one of these methods to simplify
        the implementation.</t>

        <t>Probe messages sent by a PL MUST contain enough information to
        uniquely identify the probe within Maximum Segment Lifetime, while
        being robust to reordering and replay of probe response and PTB
        messages.</t>
      </section>

      <section anchor="Valid" title="Confirmation of Probed Packet Size">
        <t>The PL needs a method to determine (confirm) when probe packets
        have been successfully received end-to-end across a network path.</t>

        <t>Transport protocols can include end-to-end methods that detect and
        report reception of specific datagrams that they send (e.g., DCCP and
        SCTP provide keep-alive/heartbeat features). When supported, this
        mechanism SHOULD also be used by DPLPMTUD to acknowledge reception of
        a probe packet.</t>

        <t>A PL that does not acknowledge data reception (e.g., UDP and
        UDP-Lite) is unable itself to detect when the packets that it sends
        are discarded because their size is greater than the actual PMTU.
        These PLs need to either rely on an application protocol to detect
        this loss, or make use of an additional transport method such as
        UDP-Options <xref target="I-D.ietf-tsvwg-udp-options"></xref>.</t>

        <t><xref target="protocol_specific_methods"></xref> specifies this function for a
        set of IETF-specified protocols.</t>
      </section>

      <section anchor="mechanism-bhd" title="Detection of Black Holes">
        <t>A PL sender needs to reduce the PLPMTU when it discovers the actual
        PMTU supported by a network path is less than the PLPMTU (i.e. to
        detect that traffic is being black holed). This can be triggered when
        a validated PTB message is received, or by another event that
        indicates the network path no longer sustains the current packet size,
        such as a loss report from the PL or repeated lack of response to
        probe packets sent to confirm the PLPMTU. Detection is followed by a
        reduction of the PLPMTU.</t>

        <t>Black Hole detection is performed by periodically sending packet
        probes of size PLPMTU to verify that a network path still supports the
        last acknowledged PLPMTU size. There are two ways a DPLPMTUD sender
        detect that the current PLPMTU is not sustained by the path (i.e., to
        detect a black hole):</t>

        <t><list style="symbols">
            <t>A PL can rely upon a mechanisms implemented within the PL
            protocol to detect excessive loss of data sent with a specific
            packet size and then conclude that this excessive loss could be a
            result of an invalid PMTU (as in PLPMTUD for TCP <xref
            target="RFC4821"></xref>).</t>

            <t>A PL can use the probing mechanism to send confirmation probe
            packets of the size of the current PLPMTU and a timer track
            whether acknowledgments are received (e.g., the number of probe
            packets sent without receiving an acknowledgement, PROBE_COUNT,
            becomes greater than the MAX_PROBES). These messages need to be
            generated periodically (e.g., using the confirmation timer <xref
            target="Timers"></xref>), and MAY inhibit sending probe packets
            when no application data has been sent since the previous probe
            packet. A PL preferring to use an up-to-data PMTU once user
            data is sent again, MAY choose to continue PMTU discovery for
            each path. However, this may result in additional packets being
            sent.
            Successive loss of probes is an indication that the current path
            no longer supports the PLPMTU.</t>
          </list></t>

        <t>When the method detects the current PLPMTU is not supported (a
        black hole is found), DPLPMTUD sets a lower MPS. The PL then confirms
        that the updated PLPMTU can be successfully used across the path. This
        can need the PL to send a probe packet with a size less than the size
        of the data block generated by an application. In this case, the PL
        could provide a way to fragment a datagram at the PL, or could instead
        utilize a control packet with padding.</t>
      </section>

      <section anchor="mechanism-ptb" title="Response to PTB Messages">
        <t>This method requires the DPLPMTUD sender to validate any received
        PTB message before using the PTB information. The response to a PTB
        message depends on the PTB_SIZE indicated in the PTB message, the
        state of the PLPMTUD state machine, and the IP protocol being
        used.</t>

        <t><xref target="PTB"></xref> first describes validation for both IPv4
        ICMP Unreachable messages (type 3) and ICMPv6 packet too big messages,
        both of which are referred to as PTB messages in this document.</t>

        <section anchor="PTB" title="Validation of PTB Messages">
          <t>This section specifies utlisation of PTB messages.</t>

          <t><list style="symbols">
              <t>A simple implementation MAY ignore received PTB messages and
              in this case the PLPMTU is not updated when a PTB message is
              received.</t>

              <t>An implementation that supports PTB messages MUST validate
              messages before they are further processed.</t>
            </list></t>

          <t>A PL that receives a PTB message from a router or middlebox,
          performs ICMP validation as specified in Section 5.2 of <xref
          target="RFC8085"></xref><xref target="RFC8201"></xref>. Because
          DPLPMTUD operates at the PL, the PL needs to check that each received
          PTB message is received in response to a packet transmitted by the
          endpoint PL performing DPLPMTUD.</t>

          <t>The PL MUST check the protocol information in the quoted packet
          carried in the ICMP PTB message payload to validate the message
          originated from the sending node. This validation includes
          determining that the combination of the IP addresses, the protocol,
          the source port and destination port match those returned in the
          quoted packet - this is also necessary for the PTB message to be
          passed to the corresponding PL.</t>

          <t>The validation SHOULD utilize information that it is not simple
          for an off-path attacker to determine. For example, by checking the
          value of a protocol header field known only to the two PL endpoints.
          A datagram application that uses well-known source and destination
          ports ought to also rely on other information to complete this
          validation.</t>

          <t>These checks are intended to provide protection from packets that
          originate from a node that is not on the network path. </t>

          <t>A PTB message that does not complete the validation MUST NOT be
          further utilized by the DPLPMTUD method.</t>

          <t>PTB messages that have been validated MAY be utilized by the
          DPLPMTUD algorithm, but MUST NOT be used directly to set the PLPMTU.
          A method that utilizes these PTB messages can improve the speed at
          the which the algorithm detects an appropriate PLPMTU, compared to
          one that relies solely on probing. <xref
          target="validPTB_SIZE"></xref> describes this processing.</t>
        </section>

        <section anchor="validPTB_SIZE" title="Use of PTB Messages">
          <t>A set of checks are intended to provide protection from a router
          that reports an unexpected PTB_SIZE. The PL needs to check that the
          indicated PTB_SIZE is less than the size used by probe packets and
          larger than minimum size accepted.</t>

          <t>This section provides a summary of how PTB messages can be
          utilized. This processing depends on the PTB_SIZE and the current
          value of a set of variables:</t>

          <t><list style="hanging">
              <t hangText="MIN_PMTU &lt; PTB_SIZE &lt; BASE_PMTU"><list
                  style="symbols">
                  <t>A robust PL MAY enter an error state (see
                  <xref target="States" />) for an IPv4 path when the PTB_SIZE
                  reported in the PTB message is larger than or equal to 68
                  bytes and when this is less than the BASE_PMTU.</t>

                  <t>A robust PL MAY enter an error state (see
                  <xref target="States" />) for an IPv6 path when the PTB_SIZE
                  reported in the PTB message is larger than or equal to 1280
                  bytes and when this is less than the BASE_PMTU.</t>
                </list></t>

              <t hangText="PTB_SIZE = PLPMTU"><list style="symbols">
                  <t>Completes the search for a better PLPMTU.</t>
                </list></t>

              <t hangText="PTB_SIZE &gt; PROBED_SIZE"><list style="symbols">
                  <t>Inconsistent network signal.</t>

                  <t>PTB message ought to be discarded without
                  further processing (e. g. PLPMTU not modified).</t>

                  <t>The information could be utilized as an input to trigger
                  enabling a resilience mode.</t>
                </list></t>

              <t hangText="BASE_PMTU &lt;= PTB_SIZE &lt; PLPMTU"><list
                  style="symbols">
                  <t>Black hole detection is triggered and the PLPMTU ought to
                  be set to BASE_PMTU.</t>

                  <t>The PL could use PTB_SIZE reported in the PTB message to
                  initialize a search algorithm.</t>
                </list></t>

              <t hangText="PLPMTU &lt; PTB_SIZE &lt; PROBED_SIZE"><list
                  style="symbols">
                  <t>The PLPMTU continues to be valid, but the last
                  PROBED_SIZE searched was larger than the actual PMTU.</t>

                  <t>The PLPMTU is not updated.</t>

                  <t>The PL can use the reported PTB_SIZE from the PTB message
                  as the next search point when it resumes the search
                  algorithm.</t>
                </list></t>
            </list></t>
        <t>xxx Author Note: Do we want to specify how to handle PTB Message
        with PTB_SIZE = 0? xxx</t>
     
        </section>
      </section>
    </section>

    <section anchor="Spec" title="Datagram Packetization Layer PMTUD">
      <t>This section specifies Datagram PLPMTUD (DPLPMTUD). The method can be
      introduced at various points (as indicated with * in the figure below)
      in the IP protocol stack to discover the PLPMTU so that an application
      can utilize an appropriate MPS for the current network path.
      DPLPMTUD SHOULD NOT be used by an application if
      it is already used in a lower layer.</t>

      <t><figure anchor="fig-plpmtudimplement"
          title="Examples where DPLPMTUD can be implemented">
          <!--
          <artset>
            <artwork type="svg" src="diagrams/dplpmtud-impl-examples.svg"></artwork>
            <artwork type="ascii-art" src="diagrams/dplpmtud-impl-examples.txt"></artwork>
          </artset>
          -->
          <artwork>
<![CDATA[
  +----------------------+
  |      Application*    |
  +-+-------+----+----+--+
    |       |    |    |
+---+--+ +--+--+ |  +-+---+
| QUIC*| |UDPO*| |  |SCTP*|
+---+--+ +--+--+ |  +--+--+
    |       |    |  |  |
    +-------+--+ |  |  |
               | |  |  |
             +-+-+--+  |
             | UDP  |  |
             +---+--+  |
                 |     |
  +--------------+-----+-+
  |  Network Interface   |
  +----------------------+
]]>
          </artwork>
        </figure></t>

      <t>The central idea of DPLPMTUD is probing by a sender. Probe packets
      are sent to find the maximum size of a user message that can be completely
      transferred across the network path from the sender to the
      destination.</t>

      <t>This section identifies the components needed for implementation, the
      phases of operation, the state machine and search algorithm.</t>

      <section anchor="dplpmtud-components" title="DPLPMTUD Components">
        <t>This section describes the timers, constants, and variables of DPLPMTUD.</t>

        <section anchor="Timers" title="Timers">
          <t>The method utilizes up to three timers:
            <list style="hanging">
              <t hangText="PROBE_TIMER:">The PROBE_TIMER is configured to
              expire after a period longer than the maximum time to receive an
              acknowledgment to a probe packet. This value MUST NOT be smaller
              than 1 second, and SHOULD be larger than 15 seconds. Guidance on
              selection of the timer value are provided in section 3.1.1 of
              the UDP Usage Guidelines <xref target="RFC8085"></xref>.</t>

              <t hangText="">If the PL has a path Round Trip Time (RTT)
              estimate and timely acknowledgements the PROBE_TIMER can be
              derived from the PL RTT estimate.</t>

              <t hangText="PMTU_RAISE_TIMER:">The PMTU_RAISE_TIMER is
              configured to the period a sender will continue to use the
              current PLPMTU, after which it re-enters the Search phase. This
              timer has a period of 600 secs, as recommended by PLPMTUD <xref
              target="RFC4821"></xref>.</t>

              <t hangText="">DPLPMTUD MAY inhibit sending probe packets when
              no application data has been sent since the previous probe packet.
              A PL preferring to use an up-to-data PMTU once user data is sent
              again, can choose to continue PMTU discovery for each path.
              However, this may result in sending additional packets.</t>

              <t hangText="CONFIRMATION_TIMER:">
              When an acknowledged PL is used, this timer MUST NOT be used.
              For other PLs, the CONFIRMATION_TIMER is
              configured to the period a PL sender waits before confirming the
              current PLPMTU is still supported. This is less than the
              PMTU_RAISE_TIMER and used to decrease the PLPMTU (e.g., when a
              black hole is encountered). Confirmation needs to be frequent
              enough when data is flowing that the sending PL does not black
              hole extensive amounts of traffic. Guidance on selection of the
              timer value are provided in section 3.1.1 of the UDP Usage
              Guidelines <xref target="RFC8085"></xref>.</t>

              <t hangText="">DPLPMTUD MAY inhibit sending probe packets when
              no application data has been sent since the previous probe packet.
              A PL preferring to use an up-to-data PMTU once user data is sent
              again, can choose to continue PMTU discovery for each path.
              However, this may result in sending additional packets.</t>
            </list></t>

          <t>An implementation could implement the various timers using a
          single timer.</t>
        </section>

        <section title="Constants">
          <t>The following constants are defined:

          <list style="hanging">
              <t hangText="MAX_PROBES:">The MAX_PROBES is the maximum value of the
              PROBE_COUNT counter (see <xref target="Variables" />). The default
              value of MAX_PROBES is 10.</t>

              <t hangText="MIN_PMTU:">The MIN_PMTU is the smallest allowed probe
              packet size. For IPv6, this value is 1280 bytes, as specified in
              <xref target="RFC2460"></xref>. For IPv4, the minimum value is
              68 bytes.<vspace />
              Note: An IPv4 router is required to be able to forward a
              datagram of 68 bytes without further fragmentation. This is the
              combined size of an IPv4 header and the minimum fragment size of
              8 bytes. In addition, receivers are required to be able to
              reassemble fragmented datagrams at least up to 576 bytes, as stated
              in section 3.3.3 of <xref target="RFC1122"></xref>.</t>

              <t hangText="MAX_PMTU:">The MAX_PMTU is the largest size of
              PLPMTU. This has to be less than or equal to the minimum of the
              local MTU of the outgoing interface and the destination PMTU for
              receiving. An application or PL MAY reduce the MAX_PMTU when
              there is no need to send packets larger than a specific
              size.</t>

              <t hangText="BASE_PMTU:">The BASE_PMTU is a configured size
              expected to work for most paths. The size is equal to or larger
              than the MIN_PMTU and smaller than the MAX_PMTU. In the case of
              IPv6, this value is 1280 bytes <xref target="RFC2460"></xref>.
              When using IPv4, a size of 1200 bytes is RECOMMENDED.</t>
            </list></t>
        </section>

        <section anchor="Variables" title="Variables">
          <t>This method utilizes a set of variables:
            <list style="hanging">
              <t hangText="PROBED_SIZE:">The PROBED_SIZE is the size of the
              current probe packet. This is a tentative value for the PLPMTU,
              which is awaiting confirmation by an acknowledgment.</t>

              <t hangText="PROBE_COUNT:">The PROBE_COUNT is a count of the
              number of unsuccessful probe packets that have been sent with a
              size of PROBED_SIZE. The value is initialized to zero when a
              particular size of PROBED_SIZE is first attempted.</t>
            </list></t>

          <t>The figure below illustrates the relationship between the packet
          size constants and variables at a point of time when the DPLPMTUD
          algorithm performs path probing to increase the size of the PLPMTU.
          A probe packet has been sent of size PROBED_SIZE. Once this is acknowledged,
          the PLPMTU will raise to PROBED_SIZE allowing the DPLPMTUD algorithm to
          further increase PROBED_SIZE towards the actual PMTU.</t>

          <t><figure anchor="fig-mps"
              title="Relationships between packet size constants and variables">

              <!--
              <artset>
                <artwork type="svg" src="diagrams/packet-sizes-relationships.svg"></artwork>
                <artwork type="ascii-art" src="diagrams/packet-sizes-relationships.txt"></artwork>
              </artset>
              -->
              <artwork>
<![CDATA[
     MIN_PMTU                                        MAX_PMTU
       <-------------------------------------------------->
                      |        |     |           |
                      v        |     |           v
                  BASE_PMTU    |     v     Actual PMTU
                               |  PROBED_SIZE
                               v
                             PLPMTU
]]>
              </artwork>

            </figure></t>
        </section>
      </section>

      <section anchor="phases" title="DPLPMTUD Phases">
        <t>The Datagram PLPMTUD algorithm moves through several phases of
        operation.</t>

        <t>An implementation that only reduces the PLPMTU to a suitable size
        would be sufficient to ensure reliable operation, but can be very
        inefficient when the actual PMTU changes or when the method (for
        whatever reason) makes a suboptimal choice for the PLPMTU.</t>

        <t>A full implementation of DPLPMTUD provides an algorithm enabling
        the DPLPMTUD sender to increase the PLPMTU following a change in the
        characteristics of the path, such as when a link is reconfigured with
        a larger MTU, or when there is a change in the set of links traversed
        by an end-to-end flow (e.g., after a routing or path fail-over
        decision).</t>

        <t>Black hole detection (<xref target="mechanism-bhd"></xref>) and
        PTB processing (<xref target="mechanism-ptb"></xref>) proceed in
        parallel with these phases of operation.</t>

        <t><figure anchor="fig-phases" title="DPLPMTUD Phases">

            <!--
            <artset>
              <artwork type="svg" src="diagrams/dplpmtud-phases.svg"></artwork>
              <artwork type="ascii-art" src="diagrams/dplpmtud-phases.txt"></artwork>
            </artset>
            -->
            <artwork>
<![CDATA[
                    +------------------------+
                    | BASE_PMTU Confirmation +-------+ Connectivity
                    +------------+-----------+       |   or BASE_PMTU
                                 |     ^             v Confirmation Fails
            Connectivity and     |     |         +-------+
             BASE_PMTU confirmed |     +---------+ Error |
                                 |               +-------+
                                 |   CONFIRMATION_TIMER
                                 |        Fires
                                 v
+----------------+          +--------------+
| Search Complete|<---------+   Search     |
+----------------+          +--------------+
                Search Algorithm
                   Completes
]]>
            </artwork>

          </figure></t>

        <t><list style="hanging">
            <t hangText="BASE_PMTU Confirmation"><list style="symbols">
                <t>Connectivity is confirmed.</t>

                <t>DPLPMTUD confirms that BASE_PMTU is supported across the
                network path.</t>

                <t>DPLPMTUD then enters the search phase.</t>
              </list></t>

            <t hangText="Search"><list style="symbols">
                <t>DPLPMTUD performs probing to increase the PLPMTU.</t>

                <t>DPLPMTUD then enters the search complete or an error
                phase.</t>
              </list></t>

            <t hangText="Search Complete"><list style="symbols">
                <t>DPLPMTUD has found a suitable PLPMTU that is supported
                across the network path.</t>

                <t>Black hole detection will confirm this PLPMTU continues to
                be supported.</t>

                <t>On a longer time-frame, DPLPMTUD will re-enter the search
                phase to discover if the PLPMTU can be raised.</t>
              </list></t>

            <t hangText="Error"><list style="symbols">
                <t>Inconsistent or invalid network signals cause DPLPMTUD to
                be unable to progress.</t>

                <t>This causes the algorithm to lower the MPS until the path
                is shown to support the BASE_PMTU, or to suspend DPLPMTUD.</t>
              </list></t>
          </list></t>

        <section anchor="phases-confirmation" title="BASE_PMTU Confirmation Phase">
          <t>DPLPMTUD starts in the BASE_PMTU confirmation phase. BASE_PMTU confirmation
          is performed in two stages:</t>

          <t><list style="numbers">
              <t>Connectivity to the remote peer is first confirmed. When a
              connection-oriented PL is used, this stage is implicit. It is
              performed as part of the normal PL connection handshake. In
              contrast, an connectionless PL MUST send an acknowledged probe
              packet to confirm that the remote peer is reachable.</t>

              <t>In the second stage, the PL confirms it can successfully send
              a datagram of the BASE_PMTU size across the current path.</t>
            </list>A PL that does not wish to support a network path with a
          PLPMTU less than BASE_PMTU can simplify the phase into a single step
          by performing connectivity checks with probes of the BASE_PMTU
          size.</t>

          <t>A PL MAY respond to PTB messages while in this phase, see <xref
          target="mechanism-ptb"></xref>.</t>

          <t>Once BASE_PMTU confirmation has completed, DPLPMTUD can advertise a
          MPS to an upper layer and then enter the Search Phase, see
          <xref target="phases-search"></xref>.</t>

          <t>If DPLPMTUD fails to complete these tests it enters the Error phase,
          see <xref target="phases-error"></xref>.</t>
        </section>

        <section anchor="phases-search" title="Search Phase">
          <t>The search phase utilizes a search algorithm in attempt to
          increase the PLPMTU (see <xref target="Increase"></xref>). The PL
          sender increases the MPS each time a packet probe confirms a larger
          PLPMTU is supported by the path. The algorithm concludes by entering
          the Search Complete phase, see <xref
          target="phases-complete"></xref>.</t>

          <t>A PL MAY respond to PTB messages while in this phase, using the
          PTB to advance or terminate the search, see <xref
          target="mechanism-ptb"></xref>. Similarly black hole detection can
          terminate the search by entering the BASE_PMTU Confirmation phase, see <xref
          target="phases-confirmation"></xref>.</t>

          <section title="Resilience to Inconsistent Path Information">
            <t>Sometimes a PL sender is able to detect inconsistent results
            from the sequence of PLPMTU probes that it sends or the sequence
            of PTB messages that it receives. This could be manifested as
            excessive fluctuation of the MPS.</t>

            <t>When inconsistent path information is detected, a PL sender can
            enable an alternate search mode that clamps the offered MPS to a
            smaller value for a period of time. This avoids unnecessary
            black-holing of packets.</t>
          </section>
        </section>

        <section anchor="phases-complete" title="Search Complete Phase">
          <t>On entry to the search complete phase, the DPLPMTUD sender starts
          the PMTU_RAISE_TIMER. The PLPMTU remains at the value
          confirmed by the last successful probe packet.</t>

          <t>In this phase, the PL MUST periodically confirm that the PLPMTU
          is still supported by the path. If the PL is designed in a way that
          is unable to confirm reachability to the destination endpoint after
          probing has completed, the method uses a CONFIRMATION_TIMER to
          periodically repeat a probe packet for the current PLPMTU size.</t>

          <t>If the DPLPMTUD sender is unable to confirm reachability for
          packets with a size of the current PLPMTU (e.g., if the
          CONFIRMATION_TIMER expires) or the PL signals a lack of
          reachability, the method exits the phase and enters the BASE_PMTU Confirmation
          phase, see <xref target="phases-confirmation"></xref>.</t>

          <t>If the PMTU_RAISE_TIMER expires, the DPLPMTUD sender re-enters
          the Search phase, see <xref target="phases-search"></xref>, and
          resumes probing for a larger PLPMTU.</t>

          <t>Back hole detection can be used in parallel to check that a
          network path continues to support a previously confirmed PLPMTU. If
          a black hole is detected the algorithm moves to the BASE_PMTU Confirmation
          phase, see <xref target="phases-confirmation"></xref>.</t>

          <t>The phase can also exited when a validated PTB message is
          received (see <xref target="PTB"></xref>).</t>
        </section>

        <section anchor="phases-error" title="Error Phase">
          <t>The ERROR phase is entered when there is conflicting or invalid
          PLPMTU information for the path (e.g. a failure to support the
          BASE_PMTU). In this phase, the MPS is set to a value less than the
          BASE_PMTU, but at least the size of the MIN_PMTU.</t>

          <t>DPLPMTUD remains in the ERROR phase until a consistent view of
          the path can be discovered and it has also been confirmed that the
          path supports the BASE_PMTU.</t>

          <t>Note: MIN_PMTU may be identical to BASE_PMTU, simplifying the
          actions in this phase.</t>

          <section anchor="robustness" title="Robustness to Inconsistent Path">
            <t>Some paths could be unable to sustain packets of the BASE_PMTU
            size. These paths could use an alternate algorithm to implement the
            Error phase that allows fallback to a smaller than desired
            PLPMTU, rather than suffer connectivity failure.</t>

            <t>This could also utilize methods such as endpoint IP
            fragmentation to enable the PL sender to communicate using packets
            smaller than the BASE_PMTU.</t>
          </section>
        </section>
      </section>

      <section anchor="States" title="State Machine">
        <t>A state machine for DPLPMTUD is depicted in <xref
        target="fig-states"></xref>. If multihoming is supported, a state
        machine is needed for each path.</t>

        <figure anchor="fig-states"
                title="State machine for Datagram PLPMTUD.  Note: Some state changes are not shown to simplify the diagram.">

            <!--
            <artset>
              <artwork type="svg" src="diagrams/dplpmtud-statemachine.svg"></artwork>
              <artwork type="ascii-art" src="diagrams/dplpmtud-statemachine.txt"></artwork>
            </artset>
            -->
            <artwork>
<![CDATA[
   |         |
   | Start   | PL indicates loss
   |         |  of connectivity
   v         v
+---------------+                                   +---------------+
|    DISABLED   |                                   |     ERROR     |
+---------------+                                   +---------------+
        | PL indicates           PROBE_TIMER expiry:   ^         |
        | connectivity        PROBE_COUNT = MAX_PROBES |         |
        +--------------------+         +---------------+         |
                             |         |                         |
                             v         |         BASE_PMTU Probe |
                          +---------------+            acked     |
                          |      BASE     |----------------------+
                          +---------------+                      |
      Black hole detected or ^ |    ^  ^ Black hole detected or  |
        PTB_SIZE < PLPMTU    | |    |  |   PTB_SIZE < PLPMTU     |
        +--------------------+ |    |  +--------------------+    |
        |                      +----+                       |    |
        |                PROBE_TIMER expiry:                |    |
        |             PROBE_COUNT < MAX_PROBES              |    |
        |                                                   |    |
        |               PMTU_RAISE_TIMER expiry             |    |
        |    +-----------------------------------------+    |    |
        |    |                                         |    |    |
        |    |                                         v    |    v
+---------------+                                   +---------------+
|SEARCH_COMPLETE|                                   |   SEARCHING   |
+---------------+                                   +---------------+
   |    ^    ^                                         |    |    ^
   |    |    |                                         |    |    |
   |    |    +-----------------------------------------+    |    |
   |    |             MAX_PMTU Probe acked or               |    |
   |    |     PTB (BASE_PMTU <= PTB_SIZE < PROBED_SIZE) or  |    |
   +----+               PROBE_COUNT = MAX_PROBES            +----+
CONFIRMATION_TIMER expiry:                        PROBE_TIMER expiry:
PROBE_COUNT < MAX_PROBES or               PROBE_COUNT < MAX_PROBES or
     PLPMTU Probe acked                           Probe acked
]]>
            </artwork>
          </figure>

        <t></t>

        <t>The following states are defined:</t>

        <t><list style="hanging">
            <t hangText="DISABLED:">The DISABLED state is the initial
            state before probing has started. It is also entered from
            any other state, when the PL indicates loss of connectivity.
            This state is left, once the PL indicates connectivity to the
            remote PL.</t>

            <t hangText="BASE:">The BASE state is used to confirm that the
            BASE_PMTU size is supported by the network path and is
            designed to allow an application to continue working when there
            are transient reductions in the actual PMTU. It also seeks to
            avoid long periods where traffic is black holed while searching
            for a larger PLPMTU.</t>

            <t hangText="">On entry, the PROBED_SIZE is set to the BASE_PMTU
            size and the PROBE_COUNT is set to zero.</t>

            <t hangText="">Each time a probe packet is sent, the
            PROBE_TIMER is started. The state is exited when the probe packet
            is acknowledged, and the PL sender enters the SEARCHING state.</t>

            <t hangText="">The state is also left when the PROBE_COUNT reaches
            MAX_PROBES; a PTB message is validated. This causes the PL sender
            to enter the ERROR state.</t>

            <t hangText="SEARCHING:">The SEARCHING state is the main
            probing state. This state is entered when probing for the
            BASE_PMTU was successful.</t>

            <t hangText="">The PROBE_COUNT is set to zero when the first probe
            packet is sent for each probe size. Each time a probe packet is
            acknowledged, the PLPMTU is set to the PROBED_SIZE, and then the
            PROBED_SIZE is increased using the search algorithm.</t>

            <t hangText="">When a probe packet is sent and not acknowledged
            within the period of the PROBE_TIMER, the PROBE_COUNT is
            incremented and the probe packet is retransmitted. The state is
            exited when the PROBE_COUNT reaches MAX_PROBES; a PTB message is
            validated; a probe of size MAX_PMTU is acknowledged or black hole
            detection is triggered.</t>

            <t hangText="SEARCH_COMPLETE:">The SEARCH_COMPLETE state indicates
            a successful end to the PROBE_SEARCH state. DPLPMTUD remains in
            this state until either the PMTU_RAISE_TIMER expires; a received
            PTB message is validated; or black hole detection is
            triggered.</t>

            <t hangText="">When DPLPMTUD uses an unacknowledged PL and is in
            the SEARCH_COMPLETE state, a CONFIRMATION_TIMER periodically
            resets the PROBE_COUNT and schedules a probe packet with the size
            of the PLPMTU. If the probe packet fails to be acknowledged after
            MAX_PROBES attempts, the method enters the BASE state. When
            used with an acknowledged PL (e.g., SCTP), DPLPMTUD SHOULD NOT
            continue to generate PLPMTU probes in this state.</t>

            <t hangText="ERROR:"> The ERROR state represents the case where
            either the network path is not known to support a PLPMTU of at
            least the BASE_PMTU size or when there is contradictory information
            about the network path that would otherwise result in excessive
            variation in the MPS signalled to the higher layer. The state
            implements a method to mitigate oscillation in the state-event
            engine. It signals a conservative value of the MPS to the higher
            layer by the PL. The state is exited when Packet Probes no longer
            detect the error or when the PL indicates that connectivity has
            been lost.</t>

            <t hangText="">Implementations are permitted to enable endpoint
            fragmentation if the DPLPMTUD is unable to validate MIN_PMTU
            within PROBE_COUNT probes. If DPLPMTUD is unable to validate
            MIN_PMTU the implementation should transition to
            PROBE_DISABLED.</t>

          </list></t>
      </section>

      <section title="Search to Increase the PLPMTU">
        <t>This section describes the algorithms used by DPLPMTUD to search
        for a larger PLPMTU.</t>

        <section anchor="Increase" title="Probing for a larger PLPMTU">
          <t>Implementations use a search algorithm across the search range to
          determine whether a larger PLPMTU can be supported across a network
          path.</t>

          <t>The method discovers the search range by confirming the minimum
          PLPMTU and then using the probe method to select a PROBED_SIZE less
          than or equal to MAX_PMTU. MAX_PMTU is the minimum of the local MTU
          and EMTU_R (learned from the remote endpoint). The MAX_PMTU MAY be
          reduced by an application that sets a maximum to the size of
          datagrams it will send.</t>

          <t>The PROBE_COUNT is initialized to zero when a probe packet is
          first sent with a particular size. A timer is used by the search
          algorithm to trigger the sending of probe packets of size
          PROBED_SIZE, larger than the PLPMTU. Each probe packet successfully
          sent to the remote peer is confirmed by acknowledgement at the PL,
          see <xref target="Probe"></xref>.</t>

          <t>Each time a probe packet is sent to the destination, the
          PROBE_TIMER is started. The timer is canceled when the PL receives
          acknowledgment that the probe packet has been successfully sent
          across the path <xref target="Probe"></xref>. This confirms that the
          PROBED_SIZE is supported, and the PROBED_SIZE value is then assigned
          to the PLPMTU. The search algorithm can continue to send subsequent
          probe packets of an increasing size.</t>

          <t>If the timer expires before a probe packet is acknowledged, the
          probe has failed to confirm the PROBED_SIZE. Each time the
          PROBE_TIMER expires, the PROBE_COUNT is incremented, the PROBE_TIMER
          is reinitialized, and a probe packet of the same size is
          retransmitted (the replicated probe improve the resilience to loss).
          The maximum number of retransmissions for a particular size is
          configured (MAX_PROBES). If the value of the PROBE_COUNT reaches
          MAX_PROBES, probing will stop, and the PL sender enters the
          SEARCH_COMPLETE state.</t>
        </section>

        <section title="Selection of Probe Sizes">
          <t>The search algorithm needs to determine a minimum useful gain in
          PLPMTU. It would not be constructive for a PL sender to attempt to
          probe for all sizes - this would incur unnecessary load on the path
          and has the undesirable effect of slowing the time to reach a more
          optimal MPS. Implementations SHOULD select the set of probe packet
          sizes to maximize the gain in PLPMTU from each search step.</t>

          <t>Implementations could optimize the search procedure by selecting
          step sizes from a table of common PMTU sizes. When selecting the
          appropriate next size to search, an implementor ought to also
          consider that there can be common sizes of MPS that applications
          seek to use.</t>

          <t>xxx Author Note: A future version of this section will detail
          example methods for selecting probe size values, but does not plan
          to mandate a single method. xxx</t>
        </section>

        <section title="Resilience to Inconsistent Path Information">
          <t>A decision to increase the PLPMTU needs to be resilient to the
          possibility that information learned about the network path is
          inconsistent (this could happen when probe packets are lost due to
          other reasons, or some of the packets in a flow are forwarded along
          a portion of the path that supports a different actual PMTU).</t>

          <t>Frequent path changes could occur due to unexpected "flapping" -
          where some packets from a flow pass along one path, but other
          packets follow a different path with different properties. DPLPMTUD
          can be made resilient to these anomalies by introducing hysteresis
          into the search decision to increase the MPS.</t>
        </section>
      </section>
    </section>

    <section anchor="protocol_specific_methods"
             title="Specification of Protocol-Specific Methods">
      <t>This section specifies protocol-specific details for datagram PLPMTUD
      for IETF-specified transports.</t>

      <t>The first subsection provides guidance on how to implement the
      DPLPMTUD method as a part of an application using UDP or UDP-Lite. The
      guidance also applies to other datagram services that do not include a
      specific transport protocol (such as a tunnel encapsulation). The
      following subsections describe how DPLPMTUD can be implemented as a part
      of the transport service, allowing applications using the service to
      benefit from discovery of the PLPMTU without themselves needing to
      implement this method.</t>

      <section title="Application support for DPLPMTUD with UDP or UDP-Lite">
        <t>The current specifications of UDP <xref target="RFC0768"></xref>
        and UDP-Lite <xref target="RFC3828"></xref> do not define a method in
        the RFC-series that supports PLPMTUD. In particular, the UDP transport
        does not provide the transport layer features needed to implement
        datagram PLPMTUD.</t>

        <t>The DPLPMTUD method can be implemented as a part of an application
        built directly or indirectly on UDP or UDP-Lite, but relies on
        higher-layer protocol features to implement the method <xref
        target="RFC8085"></xref>.</t>

        <t>Some primitives used by DPLPMTUD might not be available via the
        Datagram API (e.g., the ability to access the PLPMTU cache, or
        interpret received PTB messages).</t>

        <t>In addition, it is desirable that PMTU discovery is not performed
        by multiple protocol layers. An application SHOULD avoid using
        DPLPMTUD when the underlying transport system provides this
        capability. To use common method for managing the PLPMTU has
        benefits, both in the ability to share state between different
        processes and opportunities to coordinate probing.</t>

        <section anchor="UDP-REQ" title="Application Request ">
          <t>An application needs an application-layer protocol mechanism
          (such as a message acknowledgement method) that solicits a response
          from a destination endpoint. The method SHOULD allow the sender to
          check the value returned in the response to provide additional
          protection from off-path insertion of data <xref
          target="RFC8085"></xref>, suitable methods include a parameter known
          only to the two endpoints, such as a session ID or initialized
          sequence number.</t>
        </section>

        <section anchor="UDP-Probe" title="Application Response ">
          <t>An application needs an application-layer protocol mechanism to
          communicate the response from the destination endpoint. This
          response may indicate successful reception of the probe across the
          path, but could also indicate that some (or all packets) have failed
          to reach the destination.</t>
        </section>

        <section anchor="UDP-probing"
                 title="Sending Application Probe Packets">
          <t>A probe packet that may carry an application data block, but the
          successful transmission of this data is at risk when used for
          probing. Some applications may prefer to use a probe packet that
          does not carry an application data block to avoid disruption to
          normal data transfer.</t>
        </section>

        <section title="Validating the Path ">
          <t>An application that does not have other higher-layer information
          confirming correct delivery of datagrams SHOULD implement the
          CONFIRMATION_TIMER to periodically send probe packets while in the
          SEARCH_COMPLETE state.</t>
        </section>

        <section anchor="udpopt_ptb_handling" title="Handling of PTB Messages">
          <t>An application that is able and wishes to receive PTB messages
          MUST perform ICMP validation as specified in Section 5.2 of <xref
          target="RFC8085"></xref>. This requires that the application to
          check each received PTB messages to validate it is received in
          response to transmitted traffic and that the reported PTB_SIZE is
          less than the current probed size (see <xref
          target="validPTB_SIZE"></xref>). A validated PTB message MAY be used
          as input to the DPLPMTUD algorithm, but MUST NOT be used directly to
          set the PLPMTU.</t>
        </section>
      </section>

      <section title="DPLPMTUD for SCTP">
        <t>Section 10.2 of <xref target="RFC4821"></xref> specifies a
        recommended PLPMTUD probing method for SCTP. It recommends the use of
        the PAD chunk, defined in <xref target="RFC4820"></xref> to be
        attached to a minimum length HEARTBEAT chunk to build a probe packet.
        This enables probing without affecting the transfer of user messages
        and without interfering with congestion control. This is preferred to
        using DATA chunks (with padding as required) as path probes.</t>

        <t>XXX Author Note: Future versions of this document might define a
        parameter contained in the INIT and INIT ACK chunk to indicate the
        remote peer MTU to the local peer. However, multihoming makes this a
        bit complex, so it might not be worth doing. XXX</t>

        <section anchor="sctp_over_ip" title="SCTP/IPv4 and SCTP/IPv6">
          <t>The base protocol is specified in <xref target="RFC4960"></xref>.
          This provides an acknowledged PL. A sender can therefore enter the
          PROBE_BASE state as soon as connectivity has been confirmed.</t>

          <section anchor="sctp_over_ip_probing"
                   title="Sending SCTP Probe Packets">
            <t>Probe packets consist of an SCTP common header followed by a
            HEARTBEAT chunk and a PAD chunk. The PAD chunk is used to control
            the length of the probe packet. The HEARTBEAT chunk is used to
            trigger the sending of a HEARTBEAT ACK chunk. The reception of the
            HEARTBEAT ACK chunk acknowledges reception of a successful
            probe.</t>

            <t>The HEARTBEAT chunk carries a Heartbeat Information parameter
            which should include, besides the information suggested in <xref
            target="RFC4960"></xref>, the probe size, which is the size of the
            complete datagram. The size of the PAD chunk is therefore computed
            by reducing the probing size by the IPv4 or IPv6 header size, the
            SCTP common header, the HEARTBEAT request and the PAD chunk
            header. The payload of the PAD chunk contains arbitrary data.</t>

            <t>To avoid fragmentation of retransmitted data, probing starts
            right after the handshake, before data is sent. Assuming normal
            behavior (i.e., the PMTU is smaller than or equal to the
            interface MTU), this process will take a few round trip time
            periods depending on the number of PMTU sizes probed. The
            Heartbeat timer can be used to implement the PROBE_TIMER.</t>
          </section>

          <section title="Validating the Path with SCTP">
            <t>Since SCTP provides an acknowledged PL, a sender MUST NOT
            implement the CONFIRMATION_TIMER while in the SEARCH_COMPLETE
            state.</t>
          </section>

          <section anchor="sctp_over_ip_ptb_handling"
                   title="PTB Message Handling by SCTP">
            <t>Normal ICMP validation MUST be performed as specified in
            Appendix C of <xref target="RFC4960"></xref>. This requires that
            the first 8 bytes of the SCTP common header are quoted in the
            payload of the PTB message, which can be the case for ICMPv4 and
            is normally the case for ICMPv6.</t>

            <t>When a PTB message has been validated, the PTB_SIZE reported in
            the PTB message SHOULD be used with the DPLPMTUD algorithm,
            providing that the reported PTB_SIZE is less than the current
            probe size.</t>
          </section>
        </section>

        <section title="DPLPMTUD for SCTP/UDP">
          <t>The UDP encapsulation of SCTP is specified in <xref
          target="RFC6951"></xref>.</t>

          <section anchor="sctp_over_udp_probing"
                   title="Sending SCTP/UDP Probe Packets">
            <t>Packet probing can be performed as specified in <xref
            target="sctp_over_ip_probing"></xref>. The maximum payload is
            reduced by 8 bytes, which has to be considered when filling the
            PAD chunk.</t>
          </section>

          <section title="Validating the Path with SCTP/UDP ">
            <t>Since SCTP provides an acknowledged PL, a sender MUST NOT
            implement the CONFIRMATION_TIMER while in the SEARCH_COMPLETE
            state.</t>
          </section>

          <section anchor="sctp_over_udp_ptb_handling"
                   title="Handling of PTB Messages by SCTP/UDP">
            <t>Normal ICMP validation MUST be performed for PTB messages as
            specified in Appendix C of <xref target="RFC4960"></xref>. This
            requires that the first 8 bytes of the SCTP common header are
            contained in the PTB message, which can be the case for ICMPv4
            (but note the UDP header also consumes a part of the quoted packet
            header) and is normally the case for ICMPv6. When the validation
            is completed, the PTB_SIZE indicated in the PTB message SHOULD be
            used with the DPLPMTUD providing that the reported PTB_SIZE is
            less than the current probe size.</t>
          </section>
        </section>

        <section title="DPLPMTUD for SCTP/DTLS">
          <t>The Datagram Transport Layer Security (DTLS) encapsulation of
          SCTP is specified in <xref target="RFC8261"></xref>. It is used for
          data channels in WebRTC implementations.</t>

          <section anchor="sctp_over_dtls_probing"
                   title="Sending SCTP/DTLS Probe Packets">
            <t>Packet probing can be done as specified in <xref
            target="sctp_over_ip_probing"></xref>.</t>
          </section>

          <section title="Validating the Path with SCTP/DTLS">
            <t>Since SCTP provides an acknowledged PL, a sender MUST NOT
            implement the CONFIRMATION_TIMER while in the SEARCH_COMPLETE
            state.</t>
          </section>

          <section anchor="sctp_over_dtls_ptb_handling"
                   title="Handling of PTB Messages by SCTP/DTLS">
            <t>It is not possible to perform normal ICMP validation as
            specified in <xref target="RFC4960"></xref>, since even if the
            ICMP message payload contains sufficient information, the
            reflected SCTP common header would be encrypted. Therefore it is
            not possible to process PTB messages at the PL.</t>
          </section>
        </section>
      </section>

      <section title="DPLPMTUD for QUIC">
        <t>Quick UDP Internet Connection (QUIC) <xref
        target="I-D.ietf-quic-transport"></xref> is a UDP-based transport that
        provides reception feedback. The UDP payload includes the QUIC packet
        header, protected payload, and any authentication fields. QUIC depends
        on a PMTU of at least 1280 bytes.</t>

        <t>Section 14.1 of <xref target="I-D.ietf-quic-transport"></xref>
        describes the path considerations when sending QUIC packets. It
        recommends the use of PADDING frames to build the probe packet. Pure
        probe-only packets are constructed with PADDING frames and PING frames
        to create a padding only packet that will elicit an acknowledgement.
        Padding only frames enable probing the without affecting the transfer
        of other QUIC frames.</t>

        <t>The recommendation for QUIC endpoints implementing DPLPMTUD is
        therefore that a MPS is maintained for each combination of local and
        remote IP addresses <xref target="I-D.ietf-quic-transport"></xref>. If
        a QUIC endpoint determines that the PMTU between any pair of local and
        remote IP addresses has fallen below an acceptable MPS, it needs to
        immediately cease sending QUIC packets on the affected path. This
        could result in termination of the connection if an alternative path
        cannot be found <xref target="I-D.ietf-quic-transport"></xref>.</t>

        <section title="Sending QUIC Probe Packets">
          <t>A probe packet consists of a QUIC Header and a payload containing
          PADDING Frames and a PING Frame. PADDING Frames are a single octet
          (0x00) and several of these can be used to create a probe packet of
          size PROBED_SIZE. QUIC provides an acknowledged PL, A sender can
          therefore enter the PROBE_BASE state as soon as connectivity has
          been confirmed.</t>

          <t>The current specification of QUIC sets the following:<list
              style="symbols">
              <t>BASE_PMTU: 1200. A QUIC sender needs to pad initial packets
              to 1200 bytes to confirm the path can support packets of a
              useful size.</t>

              <t>MIN_PMTU: 1200 bytes. A QUIC sender that determines the PMTU
              has fallen below 1200 bytes MUST immediately stop sending on the
              affected path.</t>
            </list></t>
        </section>

        <section title="Validating the Path with QUIC">
          <t>QUIC provides an acknowledged PL. A sender therefore MUST NOT
          implement the CONFIRMATION_TIMER while in the SEARCH_COMPLETE
          state.</t>
        </section>

        <section title="Handling of PTB Messages by QUIC">
          <t>QUIC operates over the UDP transport, and the guidelines on ICMP
          validation as specified in Section 5.2 of <xref
          target="RFC8085"></xref> therefore apply. In addition to UDP Port
          validation QUIC can validate an ICMP message by looking for valid
          Connection IDs in the quoted packet.</t>
        </section>
      </section>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>This work was partially funded by the European Union's Horizon 2020
      research and innovation programme under grant agreement No. 644334
      (NEAT). The views expressed are solely those of the author(s).</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This memo includes no request to IANA.</t>

      <t>XXX If new UDP Options are specified in this document, a request to
      IANA will be included here. XXX</t>

      <t>If there are no requirements for IANA, the section will be removed
      during conversion into an RFC by the RFC Editor.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>The security considerations for the use of UDP and SCTP are provided
      in the references RFCs. Security guidance for applications using UDP is
      provided in the UDP Usage Guidelines <xref target="RFC8085"></xref>,
      specifically the generation of probe packets is regarded as a "Low
      Data-Volume Application", described in section 3.1.3 of this document.
      This recommends that sender limits generation of probe packets to an
      average rate lower than one probe per 3 seconds.</t>

      <t>A PL sender needs to ensure that the method used to confirm reception
      of probe packets offers protection from off-path attackers injecting
      packets into the path. This protection if provided in IETF-defined
      protocols (e.g., TCP, SCTP) using a randomly-initialized sequence
      number. A description of one way to do this when using UDP is provided
      in section 5.1 of <xref target="RFC8085"></xref>).</t>

      <t>There are cases where ICMP Packet Too Big (PTB) messages are not
      delivered due to policy, configuration or equipment design (see <xref
      target="Classic-PMTUD"></xref>), this method therefore does not rely
      upon PTB messages being received, but is able to utilize these when they
      are received by the sender. PTB messages could potentially be used to
      cause a node to inappropriately reduce the PLPMTU. A node supporting
      DPLPMTUD MUST therefore appropriately validate the payload of PTB
      messages to ensure these are received in response to transmitted traffic
      (i.e., a reported error condition that corresponds to a datagram
      actually sent by the path layer, see <xref target="PTB"></xref>).</t>

      <t>An on-path attacker, able to create a PTB message could forge PTB
      messages that include a valid quoted IP packet. Such an attack could be
      used to drive down the PLPMTU. There are two ways this method can be
      mitigated against such attacks: First, by ensuring that a PL sender
      never reduces the PLPMTU below the base size, solely in response to
      receiving a PTB message. This is achieved by first entering the
      PROBE_BASE state when such a message is received. Second, the design
      does not require processing of PTB messages, a PL sender could therefore
      suspend processing of PTB messages (e.g., in a robustness mode after
      detecting that subsequent probes actually confirm that a size larger
      than the PTB_SIZE is supported by a path).</t>

      <t>Parallel forwarding paths SHOULD be considered. <xref
      target="robustness"></xref> identifies the need for robustness in the
      method when the path information may be inconsistent.</t>

      <t>A node performing DPLPMTUD could experience conflicting information
      about the size of supported probe packets. This could occur when there
      are multiple paths are concurrently in use and these exhibit a different
      PMTU. If not considered, this could result in data being black holed
      when the PLPMTU is larger than the smallest PMTU across the current
      paths.</t>
    </section>
  </middle>

  <back>
    <!-- References split into informative and normative -->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->

      &RFC768;

      &RFC1191;

      &RFC2119;

      &RFC2460;

      &RFC3828;

      &RFC8085;

      &RFC4820;

      &RFC4960;

      &RFC6951;

      &RFC8174;

      &RFC8201;

      &RFC8261;

      &I-D.ietf-tsvwg-udp-options;

      &I-D.ietf-quic-transport;
    </references>

    <references title="Informative References">
      <!-- Here we use entities that we defined at the beginning. -->

      &RFC792;

      &RFC1122;

      &RFC1812;

      &RFC4821;

      &RFC2923;

      &RFC4340;

      &RFC4443;

      &RFC4890;

      &I-D.ietf-intarea-tunnels;
    </references>

    <section title="Revision Notes">

      <t>Note to RFC-Editor: please remove this entire section prior to
      publication.</t>

      <t>Individual draft -00: <list style="symbols">
          <t>Comments and corrections are
          welcome directly to the authors or via the IETF TSVWG working group
          mailing list.</t>

          <t>This update is proposed for WG
          comments.</t>
        </list>Individual draft -01:</t>

      <t><list style="symbols">
          <t>Contains the first representation
          of the algorithm, showing the states and timers</t>

          <t>This update is proposed for WG
          comments.</t>
        </list>Individual draft -02:</t>

      <t><list style="symbols">
          <t>Contains updated representation
          of the algorithm, and textual corrections.</t>

          <t>The text describing when to set
          the effective PMTU has not yet been validated by the authors</t>

          <t>To determine security to
          off-path-attacks: We need to decide whether a received PTB message
          SHOULD/MUST be validated? The text on how to handle a PTB message
          indicating a link MTU larger than the probe has yet not been
          validated by the authors</t>

          <t>No text currently describes how
          to handle inconsistent results from arbitrary re-routing along
          different parallel paths</t>

          <t>This update is proposed for WG
          comments.</t>
        </list>Working Group draft -00:</t>

      <t><list style="symbols">
          <t>This draft follows a successful
          adoption call for TSVWG</t>

          <t>There is still work to complete,
          please comment on this draft.</t>
        </list>Working Group draft -01:</t>

      <t><list style="symbols">
          <t>This draft includes improved
          introduction.</t>

          <t>The draft is updated to require
          ICMP validation prior to accepting PTB messages - this to be
          confirmed by WG</t>

          <t>Section added to discuss
          Selection of Probe Size - methods to be evlauated and
          recommendations to be considered</t>

          <t>Section added to align with work
          proposed in the QUIC WG.</t>
        </list>Working Group draft -02:</t>

      <t><list style="symbols">
          <t>The draft was updated based on
          feedback from the WG, and a detailed review by Magnus
          Westerlund.</t>

          <t>The document updates RFC
          4821.</t>

          <t>Requirements list updated.</t>

          <t>Added more explicit discussion of
          a simpler black-hole detection mode.</t>

          <t>This draft includes
          reorganisation of the section on IETF protocols.</t>

          <t>Added more discussion of
          implementation within an application.</t>

          <t>Added text on flapping paths.</t>

          <t>Replaced 'effective MTU' with new
          term PLPMTU.</t>
        </list></t>

      <t>Working Group draft -03:</t>

      <t><list style="symbols">
          <t>Updated figures</t>

          <t>Added more discussion on blackhole detection</t>

          <t>Added figure describing just blackhole detection</t>

          <t>Added figure relating MPS sizes</t>
        </list></t>

      <t>Working Group draft -04:</t>

      <t><list style="symbols">
          <t>Described phases and named these consistently.</t>

          <t>Corrected transition from confirmation directly to the search
          phase (Base has been checked).</t>

          <t>Redrawn state diagrams.</t>

          <t>Renamed BASE_MTU to BASE_PMTU (because it is a base for the
          PMTU).</t>

          <t>Clarified Error state.</t>

          <t>Clarified supsending DPLPMTUD.</t>

          <t>Verified normative text in requirements section.</t>

          <t>Removed duplicate text.</t>

          <t>Changed all text to refer to /packet probe/probe packet/
          /validation/verification/ added term /Probe Confirmation/ and
          clarified BlackHole detection.</t>
        </list></t>

      <t>Working Group draft -05:</t>

      <t><list style="symbols">
          <t>Updated security considerations.</t>

          <t>Feedback after speaking with Joe Touch helped improve UDP-Options
          description.</t>
        </list></t>

      <t>Working Group draft -06:</t>

      <t><list style="symbols">
          <t>Updated description of ICMP issues in section 1.1</t>

          <t>Update to description of QUIC.</t>
        </list>Working group draft -07:</t>

      <t><list style="symbols">
          <t>Moved description of the PTB processing method from the PTB
          requirements section.</t>

          <t>Clarified what is performed in the PTB validation check.</t>

          <t>Updated security consideration to explain PTB security without
          needing to read the rest of the document.</t>

      <t>Reformatted state machine diagram</t>
        </list>Working group draft -08:</t>

      <t><list style="symbols">
          <t>Moved to rfcxml v3+</t>

          <t>Rendered diagrams to svg in html version</t>

          <t>Removed Appendix A.  Event-driven state changes</t>

          <t>Removed section on DPLPMTUD with UDP Options</t>
        </list></t>

    </section>
  </back>
</rfc>
